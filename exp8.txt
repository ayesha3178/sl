import numpy as np

class ART1:
    def __init__(self, input_size, vigilance=0.8):
        self.input_size = input_size
        self.vigilance = vigilance
        self.weights = []
        self.clusters = []

    def match(self, input_vector, weight):
        min_vector = np.minimum(input_vector, weight)
        return np.sum(min_vector) / np.sum(input_vector)

    def train(self, data):
        for vector in data:
            found_cluster = False
            for i, weight in enumerate(self.weights):
                if self.match(vector, weight) >= self.vigilance:
                    # Update rule (intersection)
                    self.weights[i] = np.minimum(weight, vector)
                    self.clusters[i].append(vector)
                    found_cluster = True
                    break

            if not found_cluster:
                # Create new cluster
                self.weights.append(np.copy(vector))
                self.clusters.append([vector])

    def print_clusters(self):
        for i, cluster in enumerate(self.clusters):
            print(f"\nCluster {i+1}:")
            for vec in cluster:
                print(vec)


# Example binary input vectors
input_data = np.array([
    [1, 0, 0, 1, 0, 1],
    [1, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 1],
    [1, 1, 0, 1, 0, 0]
])

# Create ART1 network
art = ART1(input_size=6, vigilance=0.8)

# Train on data
art.train(input_data)

# Show resulting clusters
art.print_clusters()

"""
Theory Explanation:

What the program does:
This program implements the ART1 (Adaptive Resonance Theory 1) neural network for unsupervised clustering of binary input data.
It groups input patterns into clusters based on similarity, using a vigilance parameter to control how strictly inputs must match.

The key operations of the program:
1. **Initialization**:
   - Sets the input size and vigilance level.
   - Initializes empty lists for cluster weights and associated input patterns.

2. **Matching**:
   - Compares an input vector with each existing cluster using the fuzzy AND operation.
   - Computes the match score: ratio of intersection to input vector sum.
   - Accepts the input into a cluster if the score ≥ vigilance.

3. **Training**:
   - If an input matches a cluster, the cluster's weight is updated via intersection (min operation).
   - If no match is found, a new cluster is created with the input as its prototype.

4. **Output**:
   - After training, clusters are printed showing how the data was grouped.

Potential real-life use cases:
- Clustering text documents (converted to binary vectors).
- Recognizing handwritten binary digits.
- Binary pattern classification in cognitive modeling.
- Real-time pattern learning in robotics or adaptive systems.

A sample input/output scenario with explanation:
Input:
    [1, 0, 0, 1, 0, 1]  
    [1, 1, 0, 1, 0, 1]
    [0, 0, 1, 0, 1, 0]
    [0, 0, 1, 0, 1, 1]
    [1, 1, 0, 1, 0, 0]

Clusters might form like:
    Cluster 1: patterns 1, 2, and 5 (similar structure with high overlap)
    Cluster 2: patterns 3 and 4 (shared active bits in different positions)

Explanation:
The ART1 model assigns inputs to clusters only if the match score is above 0.8.
Patterns with sufficient overlap are grouped; otherwise, new clusters are formed.
This preserves learned clusters and prevents overwriting—key to stable category learning.
"""
